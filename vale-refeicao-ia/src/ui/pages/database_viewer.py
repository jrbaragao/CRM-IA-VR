"""
P√°gina para visualizar e gerenciar tabelas do banco de dados
"""

import streamlit as st
import pandas as pd
from datetime import datetime

from ..components import (
    render_alert,
    render_metrics_row,
    safe_columns
)
from ...data.database import get_db_manager
from ...config.settings import settings
from ...agents.log_utils import log_agent_action

def render():
    """Renderiza p√°gina de visualiza√ß√£o do banco de dados"""
    st.header("üóÉÔ∏è Visualizador de Banco de Dados")
    st.caption("Visualize e gerencie as tabelas criadas dinamicamente")
    
    # Inicializar banco de dados
    db = get_db_manager()
    
    # Testar conex√£o
    if not db.test_connection():
        render_alert("‚ùå Erro de conex√£o com o banco de dados", "error")
        return
    
    # Listar tabelas
    try:
        tables = db.list_tables()
        
        if not tables:
            render_alert("üì≠ Nenhuma tabela encontrada no banco de dados", "info")
            st.markdown("### üí° Como criar tabelas:")
            st.markdown("1. V√° para a p√°gina **Upload de Arquivos**")
            st.markdown("2. Fa√ßa upload de planilhas CSV ou Excel")
            st.markdown("3. Processe os arquivos na p√°gina **Processamento**")
            st.markdown("4. Cada arquivo criar√° uma tabela automaticamente!")
            return
        
        # Separar tabelas do sistema das tabelas de dados
        system_tables = ['importacoes', 'agent_logs', 'calculation_configs']
        data_tables = [t for t in tables if t not in system_tables]
        
        # M√©tricas gerais
        total_registros = 0
        for table in data_tables:
            info = db.get_table_info(table)
            if info:
                total_registros += info.get('total_rows', 0)
        
        # Contar configura√ß√µes de c√°lculo
        calculation_configs_count = len(db.get_calculation_configs())
        
        metrics = [
            {'label': 'Total de Tabelas', 'value': len(tables)},
            {'label': 'Tabelas de Dados', 'value': len(data_tables)},
            {'label': 'Tabelas do Sistema', 'value': len(system_tables)},
            {'label': 'Configura√ß√µes de C√°lculo', 'value': calculation_configs_count},
            {'label': 'Total de Registros', 'value': total_registros}
        ]
        render_metrics_row(metrics)
        
        # Limpar qualquer session_state residual de controle de abas
        keys_to_remove = ['active_db_tab_index', 'tab_selector', 'force_query_tab']
        for key in keys_to_remove:
            if key in st.session_state:
                del st.session_state[key]
        
        # Tabs nativas do Streamlit (ATUALIZADO - sem controle de sess√£o)
        tab1, tab2, tab3, tab4, tab5 = st.tabs([
            "üìä Tabelas de Dados", 
            "üîó Correla√ß√µes", 
            "‚öôÔ∏è Tabelas do Sistema", 
            "üîç Buscas (Query)",
            "üîß Ferramentas"
        ])
        
        with tab1:
            render_data_tables(db, data_tables)
        
        with tab2:
            render_table_correlations(db, data_tables)
        
        with tab3:
            render_system_tables(db, system_tables)
        
        with tab4:
            render_query_interface(db, tables)
        
        with tab5:
            render_database_tools(db, tables)
            
    except Exception as e:
        render_alert(f"‚ùå Erro ao acessar banco de dados: {str(e)}", "error")

def render_data_tables(db, data_tables):
    """Renderiza tabelas de dados criadas pelos uploads"""
    if not data_tables:
        st.info("üì≠ Nenhuma tabela de dados encontrada")
        st.markdown("**Dica:** Fa√ßa upload e processamento de arquivos para criar tabelas automaticamente!")
        return
    
    st.subheader(f"üìä Tabelas de Dados ({len(data_tables)})")
    
    # An√°lise de chaves prim√°rias
    tables_with_pk = 0
    tables_without_pk = 0
    
    for table in data_tables:
        table_info = db.get_table_info(table)
        if table_info:
            primary_keys = [col['name'] for col in table_info['columns'] if col['primary_key']]
            if primary_keys:
                tables_with_pk += 1
            else:
                tables_without_pk += 1
    
    # Mostrar resumo de chaves prim√°rias
    if tables_without_pk > 0:
        st.warning(f"‚ö†Ô∏è {tables_without_pk} tabela(s) sem chave prim√°ria definida. Isso pode afetar correla√ß√µes entre dados.")
        st.info("üí° **Dica:** Configure chaves prim√°rias na se√ß√£o 'Estrutura da Tabela' abaixo para melhorar correla√ß√µes.")
    else:
        st.success(f"‚úÖ Todas as {tables_with_pk} tabelas t√™m chave prim√°ria definida!")
    
    # M√©tricas resumidas
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("üîë Com Chave Prim√°ria", tables_with_pk)
    with col2:
        st.metric("‚ö†Ô∏è Sem Chave Prim√°ria", tables_without_pk)
    with col3:
        st.metric("üìä Total de Tabelas", len(data_tables))
    
    st.markdown("---")
    
    for table in data_tables:
        try:
            # Obter informa√ß√µes da tabela
            table_info = db.get_table_info(table)
            
            if not table_info:
                continue
            
            # Verificar se tem chave prim√°ria definida
            primary_keys = [col['name'] for col in table_info['columns'] if col['primary_key']]
            pk_indicator = "üîë" if primary_keys else "‚ö†Ô∏è"
            pk_status = "PK definida" if primary_keys else "Sem PK"
            
            # Expandir para cada tabela com indicador de PK
            with st.expander(f"{pk_indicator} {table} ({table_info['total_rows']} registros) - {pk_status}", expanded=False):
                
                # Informa√ß√µes b√°sicas
                cols = safe_columns(4)
                if cols:
                    col1, col2, col3, col4 = cols
                    
                    with col1:
                        st.metric("Registros", table_info['total_rows'])
                    
                    with col2:
                        st.metric("Colunas", len(table_info['columns']))
                    
                    with col3:
                        primary_keys = [col['name'] for col in table_info['columns'] if col['primary_key']]
                        st.metric("Chaves Prim√°rias", len(primary_keys))
                    
                    with col4:
                        # Bot√£o para remover tabela
                        if st.button(f"üóëÔ∏è Remover", key=f"delete_{table}", help="Remove esta tabela"):
                            if st.session_state.get(f'confirm_delete_{table}', False):
                                if db.drop_table(table):
                                    st.success(f"Tabela '{table}' removida!")
                                    st.rerun()
                            else:
                                st.session_state[f'confirm_delete_{table}'] = True
                                st.warning("Clique novamente para confirmar a remo√ß√£o")
                
                # Estrutura da tabela com edi√ß√£o de PK
                st.markdown("**üìã Estrutura da Tabela:**")
                
                # Destacar se n√£o tem chave prim√°ria
                if not primary_keys:
                    st.error("‚ö†Ô∏è **Esta tabela n√£o possui chave prim√°ria definida!**")
                    st.markdown("**Por que isso √© importante?**")
                    st.markdown("- Chaves prim√°rias s√£o essenciais para correlacionar dados entre tabelas")
                    st.markdown("- Agentes aut√¥nomos usam PKs para fazer JOINs inteligentes")
                    st.markdown("- Melhora performance das consultas")
                    st.markdown("**üëá Configure uma chave prim√°ria abaixo:**")
                    
                    # Sugerir colunas candidatas para PK
                    candidate_columns = []
                    for col in table_info['columns']:
                        col_name = col['name'].lower()
                        if any(term in col_name for term in ['id', 'codigo', 'matricula', 'cpf', 'cnpj', 'registro']):
                            candidate_columns.append(col['name'])
                    
                    if candidate_columns:
                        st.info(f"üí° **Sugest√µes de colunas para chave prim√°ria:** {', '.join(candidate_columns)}")
                    else:
                        st.info("üí° **Dica:** Procure por colunas com valores √∫nicos como ID, c√≥digo, matr√≠cula, etc.")
                
                render_editable_table_structure(db, table, table_info)
                
                # Preview dos dados
                st.markdown("**üëÄ Preview dos Dados:**")
                
                # Controles de visualiza√ß√£o
                col_limit, col_refresh = st.columns([3, 1])
                
                with col_limit:
                    limit = st.selectbox(
                        "Registros para mostrar:",
                        [10, 25, 50, 100],
                        key=f"limit_{table}"
                    )
                
                with col_refresh:
                    st.write("")  # Espa√ßamento
                    if st.button("üîÑ Atualizar", key=f"refresh_{table}"):
                        st.rerun()
                
                # Buscar e mostrar dados
                df_table = db.get_table_data(table, limit=limit)
                
                if not df_table.empty:
                    st.dataframe(df_table, use_container_width=True)
                    
                    # Op√ß√£o de download
                    csv = df_table.to_csv(index=False)
                    st.download_button(
                        label=f"üì• Baixar {table}.csv",
                        data=csv,
                        file_name=f"{table}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv",
                        key=f"download_{table}"
                    )
                else:
                    st.warning("Nenhum dado encontrado na tabela")
                    
        except Exception as e:
            st.error(f"‚ùå Erro ao carregar tabela '{table}': {str(e)}")

def render_editable_table_structure(db, table_name: str, table_info: dict):
    """Renderiza estrutura da tabela com possibilidade de editar chave prim√°ria"""
    
    # Obter colunas
    columns = table_info['columns']
    
    # Identificar chave prim√°ria atual
    current_pk = None
    for col in columns:
        if col['primary_key']:
            current_pk = col['name']
            break
    
    # Interface para alterar chave prim√°ria
    st.markdown("**üîë Configura√ß√£o de Chave Prim√°ria:**")
    
    col1, col2, col3 = st.columns([2, 2, 1])
    
    with col1:
        # Lista de colunas dispon√≠veis
        column_options = ['(Nenhuma)'] + [col['name'] for col in columns]
        current_index = 0
        
        if current_pk:
            try:
                current_index = column_options.index(current_pk)
            except ValueError:
                current_index = 0
        
        new_pk = st.selectbox(
            "Chave Prim√°ria:",
            options=column_options,
            index=current_index,
            key=f"pk_select_{table_name}",
            help="Selecione qual coluna ser√° a chave prim√°ria para correlacionar com outras tabelas"
        )
    
    with col2:
        # Mostrar dados de exemplo da coluna selecionada
        if new_pk and new_pk != '(Nenhuma)':
            sample_data = db.get_column_sample_data(table_name, new_pk, limit=3)
            if sample_data:
                st.markdown("**Exemplos:**")
                for i, sample in enumerate(sample_data, 1):
                    st.caption(f"{i}. {sample}")
            else:
                st.caption("Sem dados de exemplo")
        else:
            st.caption("Nenhuma chave prim√°ria selecionada")
    
    with col3:
        # Bot√£o para aplicar mudan√ßa
        if st.button("üíæ Aplicar", key=f"apply_pk_{table_name}"):
            # Determinar nova PK
            new_primary_key = new_pk if new_pk != '(Nenhuma)' else None
            
            # Verificar se houve mudan√ßa
            if new_primary_key != current_pk:
                with st.spinner("Alterando chave prim√°ria..."):
                    success = db.update_primary_key(table_name, current_pk, new_primary_key)
                    if success:
                        st.rerun()
            else:
                st.info("Nenhuma altera√ß√£o detectada")
    
    # Mostrar estrutura atual
    st.markdown("**üìä Estrutura Atual:**")
    
    # Criar DataFrame para mostrar estrutura
    structure_data = []
    for col in columns:
        # Destacar chave prim√°ria
        pk_status = "üîë Sim" if col['primary_key'] else "‚ùå N√£o"
        
        structure_data.append({
            'Coluna': col['name'],
            'Tipo': col['type'],
            'Permite Nulo': "‚ùå N√£o" if col['not_null'] else "‚úÖ Sim",
            'Chave Prim√°ria': pk_status
        })
    
    structure_df = pd.DataFrame(structure_data)
    
    # Aplicar estilo para destacar chave prim√°ria
    def highlight_primary_key(row):
        if row['Chave Prim√°ria'] == "üîë Sim":
            return ['background-color: #e8f5e8'] * len(row)
        return [''] * len(row)
    
    styled_df = structure_df.style.apply(highlight_primary_key, axis=1)
    st.dataframe(styled_df, use_container_width=True, hide_index=True)
    
    # Dicas sobre chaves prim√°rias (usando container em vez de expander)
    st.markdown("---")
    if st.checkbox("üí° Mostrar Dicas sobre Chaves Prim√°rias", key=f"show_tips_{table_name}"):
        st.markdown("""
        **Para que serve a chave prim√°ria?**
        - Identifica unicamente cada registro na tabela
        - Permite correlacionar dados entre diferentes tabelas
        - Melhora a performance das consultas
        
        **Boas pr√°ticas:**
        - Escolha uma coluna com valores √∫nicos (ex: MATRICULA, ID, CPF)
        - Evite colunas que podem ter valores duplicados (ex: NOME, DEPARTAMENTO)
        - Prefira valores que n√£o mudam com frequ√™ncia
        
        **Exemplos comuns:**
        - `MATRICULA` - Para dados de funcion√°rios
        - `ID` - Para identificadores √∫nicos
        - `CPF` - Para pessoas f√≠sicas
        - `CNPJ` - Para empresas
        """)
        
        # Mostrar an√°lise de unicidade das colunas
        st.markdown("**üîç An√°lise de Unicidade das Colunas:**")
        
        uniqueness_data = []
        df_sample = db.get_table_data(table_name, limit=1000)  # Amostra para an√°lise
        
        if not df_sample.empty:
            for col_name in df_sample.columns:
                if col_name not in ['created_at', 'updated_at']:  # Pular metadados
                    total_rows = len(df_sample)
                    unique_values = df_sample[col_name].nunique()
                    null_count = df_sample[col_name].isnull().sum()
                    uniqueness_pct = (unique_values / total_rows) * 100 if total_rows > 0 else 0
                    
                    # Recomenda√ß√£o
                    if uniqueness_pct >= 95 and null_count == 0:
                        recommendation = "üü¢ Excelente para PK"
                    elif uniqueness_pct >= 80 and null_count <= total_rows * 0.05:
                        recommendation = "üü° Boa para PK"
                    else:
                        recommendation = "üî¥ N√£o recomendada"
                    
                    uniqueness_data.append({
                        'Coluna': col_name,
                        'Valores √önicos': unique_values,
                        'Total Registros': total_rows,
                        'Unicidade (%)': f"{uniqueness_pct:.1f}%",
                        'Valores Nulos': null_count,
                        'Recomenda√ß√£o': recommendation
                    })
            
            if uniqueness_data:
                uniqueness_df = pd.DataFrame(uniqueness_data)
                st.dataframe(uniqueness_df, use_container_width=True, hide_index=True)

def render_table_correlations(db, data_tables):
    """Renderiza an√°lise de correla√ß√µes entre tabelas"""
    st.subheader("üîó Correla√ß√µes entre Tabelas")
    st.caption("Analise como as tabelas podem se relacionar atrav√©s das chaves prim√°rias")
    
    if len(data_tables) < 2:
        st.info("üì≠ Voc√™ precisa de pelo menos 2 tabelas para analisar correla√ß√µes")
        st.markdown("**Dica:** Fa√ßa upload de mais planilhas para ver as correla√ß√µes!")
        return
    
    # Obter informa√ß√µes de todas as tabelas
    tables_info = {}
    for table in data_tables:
        info = db.get_table_info(table)
        if info:
            tables_info[table] = info
    
    if not tables_info:
        st.warning("‚ö†Ô∏è N√£o foi poss√≠vel obter informa√ß√µes das tabelas")
        return
    
    # An√°lise de correla√ß√µes poss√≠veis
    st.markdown("### üîç An√°lise de Correla√ß√µes Poss√≠veis")
    
    correlations = []
    
    # Comparar cada tabela com as outras
    for table1 in tables_info:
        for table2 in tables_info:
            if table1 != table2:
                # Buscar colunas em comum
                cols1 = {col['name'].upper(): col for col in tables_info[table1]['columns']}
                cols2 = {col['name'].upper(): col for col in tables_info[table2]['columns']}
                
                common_columns = set(cols1.keys()) & set(cols2.keys())
                common_columns.discard('CREATED_AT')  # Remover metadados
                common_columns.discard('UPDATED_AT')
                
                if common_columns:
                    for col_name in common_columns:
                        # Verificar se alguma √© chave prim√°ria
                        is_pk1 = cols1[col_name]['primary_key']
                        is_pk2 = cols2[col_name]['primary_key']
                        
                        correlation_type = "üîë Chave Prim√°ria" if (is_pk1 or is_pk2) else "üîó Coluna Comum"
                        strength = "Alta" if (is_pk1 or is_pk2) else "M√©dia"
                        
                        correlations.append({
                            'Tabela 1': table1,
                            'Tabela 2': table2,
                            'Coluna Comum': col_name,
                            'Tipo': correlation_type,
                            'For√ßa': strength
                        })
    
    if correlations:
        correlations_df = pd.DataFrame(correlations)
        st.dataframe(correlations_df, use_container_width=True, hide_index=True)
        
        # Sugest√µes de JOIN
        st.markdown("### üí° Sugest√µes de Consultas JOIN")
        
        # Agrupar por pares de tabelas
        table_pairs = {}
        for corr in correlations:
            pair_key = f"{corr['Tabela 1']} + {corr['Tabela 2']}"
            if pair_key not in table_pairs:
                table_pairs[pair_key] = []
            table_pairs[pair_key].append(corr)
        
        for pair_key, pair_correlations in table_pairs.items():
            table1, table2 = pair_key.split(' + ')
            
            # Usar container com checkbox em vez de expander
            st.markdown(f"### üîó {table1} ‚Üî {table2}")
            if st.checkbox(f"Mostrar detalhes da correla√ß√£o", key=f"show_corr_{table1}_{table2}"):
                st.markdown(f"**Colunas em comum:** {len(pair_correlations)}")
                
                # Mostrar colunas comuns
                for corr in pair_correlations:
                    col_name = corr['Coluna Comum']
                    corr_type = corr['Tipo']
                    
                    # Gerar SQL de exemplo
                    sql_example = f"""
-- Juntar {table1} com {table2} usando {col_name}
SELECT 
    t1.*,
    t2.*
FROM "{table1}" t1
INNER JOIN "{table2}" t2 ON t1."{col_name}" = t2."{col_name}"
LIMIT 10;
                    """
                    
                    st.markdown(f"**{corr_type} - {col_name}:**")
                    st.code(sql_example.strip(), language='sql')
                    
                    # Bot√£o para executar consulta
                    if st.button(f"‚ñ∂Ô∏è Executar JOIN", key=f"join_{table1}_{table2}_{col_name}"):
                        try:
                            join_query = f'''
                            SELECT t1.*, t2.*
                            FROM "{table1}" t1
                            INNER JOIN "{table2}" t2 ON t1."{col_name}" = t2."{col_name}"
                            LIMIT 50
                            '''
                            
                            result_df = pd.read_sql(join_query, db.engine)
                            
                            if not result_df.empty:
                                st.success(f"‚úÖ JOIN executado! {len(result_df)} registros encontrados.")
                                st.dataframe(result_df, use_container_width=True)
                                
                                # Op√ß√£o de download
                                csv = result_df.to_csv(index=False)
                                st.download_button(
                                    label=f"üì• Baixar resultado do JOIN",
                                    data=csv,
                                    file_name=f"join_{table1}_{table2}_{col_name}.csv",
                                    mime="text/csv",
                                    key=f"download_join_{table1}_{table2}_{col_name}"
                                )
                            else:
                                st.warning("‚ö†Ô∏è Nenhum registro encontrado no JOIN")
                                
                        except Exception as e:
                            st.error(f"‚ùå Erro ao executar JOIN: {str(e)}")
            
            st.markdown("---")  # Separador entre correla√ß√µes
    else:
        st.info("üì≠ Nenhuma correla√ß√£o encontrada entre as tabelas")
        st.markdown("""
        **Para criar correla√ß√µes:**
        1. Certifique-se de que as tabelas tenham colunas com nomes similares
        2. Configure chaves prim√°rias nas tabelas
        3. Use nomes padronizados (ex: MATRICULA, ID, CPF)
        """)
    
    # Resumo das chaves prim√°rias
    st.markdown("### üîë Resumo das Chaves Prim√°rias")
    
    pk_summary = []
    for table_name, info in tables_info.items():
        primary_keys = [col['name'] for col in info['columns'] if col['primary_key']]
        pk_status = primary_keys[0] if primary_keys else "‚ùå Sem chave prim√°ria"
        
        pk_summary.append({
            'Tabela': table_name,
            'Chave Prim√°ria': pk_status,
            'Total Registros': info['total_rows']
        })
    
    pk_df = pd.DataFrame(pk_summary)
    st.dataframe(pk_df, use_container_width=True, hide_index=True)
    
    # Dicas para melhorar correla√ß√µes (usando container)
    st.markdown("---")
    if st.checkbox("üí° Mostrar Dicas para Melhorar Correla√ß√µes", key="show_correlation_tips"):
        st.markdown("""
        **1. Padronize os nomes das colunas:**
        - Use `MATRICULA` em todas as tabelas de funcion√°rios
        - Use `ID` para identificadores √∫nicos
        - Use `CPF` para pessoas f√≠sicas
        
        **2. Configure chaves prim√°rias:**
        - V√° na aba "Tabelas de Dados"
        - Expanda cada tabela
        - Configure a chave prim√°ria apropriada
        
        **3. Mantenha consist√™ncia:**
        - Mesmos tipos de dados nas colunas relacionadas
        - Mesma formata√ß√£o (ex: CPF com ou sem pontos)
        - Valores √∫nicos nas chaves prim√°rias
        
        **4. Teste as correla√ß√µes:**
        - Use os JOINs sugeridos acima
        - Verifique se os resultados fazem sentido
        - Ajuste as chaves prim√°rias se necess√°rio
        """)

def render_query_interface(db, tables):
    """Renderiza interface de consultas e buscas"""
    
    st.markdown("### üîç Interface de Consultas")
    st.caption("Fa√ßa consultas inteligentes aos seus dados")
    
    # Informa√ß√£o sobre persist√™ncia de resultados
    if ('current_generated_sql' in st.session_state or 
        st.session_state.get('execute_current_sql', False)):
        st.info("üí° **Dica**: Os resultados das consultas aparecem nesta mesma aba. N√£o √© necess√°rio navegar entre abas!")
    
    # Debug info (remover ap√≥s teste)
    if st.checkbox("üîß Mostrar Debug", key="show_debug"):
        st.write("**Debug Info:**")
        st.write(f"- Aba ativa: {st.session_state.get('active_db_tab_index', 'n√£o definida')}")
        st.write(f"- Consulta SQL ativa: {'Sim' if 'current_generated_sql' in st.session_state else 'N√£o'}")
        st.write(f"- Executar SQL: {'Sim' if st.session_state.get('execute_current_sql', False) else 'N√£o'}")
        st.write(f"- For√ßar aba Query: {'Sim' if st.session_state.get('force_query_tab', False) else 'N√£o'}")
    
    # Separar tabelas do sistema das tabelas de dados
    system_tables = ['importacoes', 'agent_logs', 'calculation_configs']
    data_tables = [t for t in tables if t not in system_tables]
    
    if not data_tables:
        st.warning("‚ö†Ô∏è Nenhuma tabela de dados dispon√≠vel para consulta.")
        st.info("üí° Fa√ßa upload e processe arquivos primeiro para criar tabelas de dados.")
        return
    
    # Sub-tabs para diferentes tipos de consulta
    query_tab1, query_tab2, query_tab3 = st.tabs([
        "ü§ñ Consulta com IA (Prompt to Query)",
        "üß† Consulta com Agente de IA",
        "üîç Consulta SQL Avan√ßada"
    ])
    
    with query_tab1:
        render_ai_query_interface(db, data_tables)
    
    with query_tab2:
        render_autonomous_agent_interface(db, data_tables)
    
    with query_tab3:
        render_advanced_sql_interface(db, tables)

def render_system_tables(db, system_tables):
    """Renderiza tabelas do sistema"""
    st.subheader("‚öôÔ∏è Tabelas do Sistema")
    st.caption("Tabelas internas do sistema para controle, logs e configura√ß√µes")
    
    existing_system_tables = [t for t in system_tables if t in db.list_tables()]
    
    if not existing_system_tables:
        st.info("üì≠ Nenhuma tabela do sistema encontrada")
        return
    
    # Descri√ß√µes das tabelas do sistema
    table_descriptions = {
        'importacoes': 'üì• Registro de importa√ß√µes de arquivos',
        'agent_logs': 'ü§ñ Logs de atividades dos agentes',
        'calculation_configs': '‚öôÔ∏è Configura√ß√µes de prompts para agentes de c√°lculo'
    }
    
    for table in existing_system_tables:
        try:
            table_info = db.get_table_info(table)
            
            if not table_info:
                continue
            
            # Usar descri√ß√£o personalizada se dispon√≠vel
            description = table_descriptions.get(table, f"‚öôÔ∏è {table}")
            with st.expander(f"{description} ({table_info['total_rows']} registros)", expanded=False):
                
                # Informa√ß√µes b√°sicas
                col1, col2 = st.columns(2)
                
                with col1:
                    st.metric("Registros", table_info['total_rows'])
                
                with col2:
                    st.metric("Colunas", len(table_info['columns']))
                
                # Estrutura da tabela
                st.markdown("**üìã Estrutura:**")
                columns_df = pd.DataFrame(table_info['columns'])
                st.dataframe(columns_df, use_container_width=True, hide_index=True)
                
                # Preview espec√≠fico para cada tipo de tabela
                if table == 'calculation_configs':
                    # Para configura√ß√µes de c√°lculo, mostrar informa√ß√µes mais √∫teis
                    configs = db.get_calculation_configs()
                    if configs:
                        st.markdown("**üîß Configura√ß√µes Ativas:**")
                        for config in configs[:3]:  # Mostrar apenas as 3 primeiras
                            st.markdown(f"‚Ä¢ **{config['name']}**: {config['description'][:50]}...")
                        
                        if len(configs) > 3:
                            st.caption(f"... e mais {len(configs) - 3} configura√ß√µes")
                    else:
                        st.info("Nenhuma configura√ß√£o de c√°lculo criada ainda")
                
                # Preview padr√£o para outras tabelas
                if st.button(f"üëÄ Ver √öltimos Registros", key=f"preview_system_{table}"):
                    df_table = db.get_table_data(table, limit=5)
                    if not df_table.empty:
                        st.dataframe(df_table, use_container_width=True)
                    else:
                        st.warning("Nenhum dado encontrado")
                        
        except Exception as e:
            st.error(f"‚ùå Erro ao carregar tabela do sistema '{table}': {str(e)}")

def render_autonomous_agent_interface(db, data_tables):
    """Renderiza interface do agente aut√¥nomo de IA"""
    
    st.markdown("### üß† Agente Aut√¥nomo de IA")
    st.caption("Agente inteligente que executa m√∫ltiplas etapas para responder perguntas complexas")
    
    # Informa√ß√µes sobre o agente
    with st.expander("‚ÑπÔ∏è Como funciona o Agente Aut√¥nomo", expanded=False):
        st.markdown("""
        **O Agente Aut√¥nomo √© diferente da consulta simples:**
        
        üîç **An√°lise Inteligente:**
        - Analisa sua pergunta e planeja etapas
        - Explora o esquema das tabelas automaticamente
        - Faz consultas explorat√≥rias para entender os dados
        
        üîÑ **Processo Iterativo:**
        - Executa m√∫ltiplas consultas SQL se necess√°rio
        - Refina a busca com base nos resultados
        - Combina informa√ß√µes de diferentes tabelas
        
        üéØ **Resposta Completa:**
        - Apresenta an√°lise detalhada
        - Mostra o racioc√≠nio usado
        - Fornece insights e recomenda√ß√µes
        
        **Exemplos de perguntas complexas:**
        - "Analise o perfil dos funcion√°rios e identifique padr√µes salariais"
        - "Qual departamento tem melhor performance e por qu√™?"
        - "Encontre anomalias nos dados e sugira corre√ß√µes"
        """)
    
    # Configura√ß√µes do agente
    st.markdown("### ‚öôÔ∏è Configura√ß√µes do Agente")
    
    col1, col2 = st.columns(2)
    
    with col1:
        max_iterations = st.slider(
            "üîÑ M√°ximo de Itera√ß√µes",
            min_value=1,
            max_value=10,
            value=5,
            help="N√∫mero m√°ximo de etapas que o agente pode executar"
        )
        
        exploration_depth = st.selectbox(
            "üîç Profundidade de Explora√ß√£o",
            options=["B√°sica", "Intermedi√°ria", "Avan√ßada"],
            index=1,
            help="Qu√£o detalhada ser√° a an√°lise inicial dos dados"
        )
    
    with col2:
        include_insights = st.checkbox(
            "üí° Incluir Insights",
            value=True,
            help="Agente fornecer√° insights e recomenda√ß√µes"
        )
        
        show_reasoning = st.checkbox(
            "üß† Mostrar Racioc√≠nio",
            value=True,
            help="Exibir o processo de pensamento do agente"
        )
    
    # Campo de pergunta
    st.markdown("### üí¨ Sua Pergunta Complexa")
    
    user_question = st.text_area(
        "Descreva o que voc√™ quer descobrir:",
        placeholder="Ex: Analise os dados de funcion√°rios e identifique quais departamentos t√™m maior rotatividade, correlacionando com sal√°rios e tempo de empresa. Sugira a√ß√µes para melhorar a reten√ß√£o.",
        height=120,
        help="Seja espec√≠fico sobre o que voc√™ quer analisar. O agente pode lidar com perguntas complexas que requerem m√∫ltiplas an√°lises."
    )
    
    # Informa√ß√µes contextuais
    col1, col2 = st.columns([2, 1])
    
    with col1:
        if st.button("üöÄ Iniciar An√°lise Aut√¥noma", type="primary", disabled=not user_question.strip()):
            if not user_question.strip():
                st.warning("‚ö†Ô∏è Digite uma pergunta primeiro!")
            else:
                # Container para o processo do agente
                agent_container = st.empty()
                execute_autonomous_agent(db, data_tables, user_question, {
                    'max_iterations': max_iterations,
                    'exploration_depth': exploration_depth,
                    'include_insights': include_insights,
                    'show_reasoning': show_reasoning
                }, agent_container)
    
    with col2:
        st.markdown("**üìã Tabelas dispon√≠veis:**")
        for table in data_tables:
            table_info = db.get_table_info(table)
            if table_info:
                st.caption(f"‚Ä¢ **{table}** ({table_info['total_rows']} registros)")
    
    # Hist√≥rico de an√°lises do agente
    if 'agent_analyses' in st.session_state and st.session_state['agent_analyses']:
        st.markdown("---")
        st.markdown("### üìö Hist√≥rico de An√°lises")
        
        for i, analysis in enumerate(st.session_state['agent_analyses'][-3:]):  # √öltimas 3
            with st.expander(f"üß† {analysis['question'][:60]}...", expanded=False):
                st.markdown(f"**Pergunta:** {analysis['question']}")
                st.markdown(f"**Data:** {analysis['timestamp']}")
                st.markdown(f"**Itera√ß√µes:** {analysis['iterations']}")
                
                if st.button(f"üîÑ Repetir An√°lise", key=f"repeat_analysis_{i}"):
                    # Repetir an√°lise com mesmos par√¢metros
                    agent_container = st.empty()
                    execute_autonomous_agent(db, data_tables, analysis['question'], 
                                           analysis['config'], agent_container)

def render_advanced_sql_interface(db, tables):
    """Renderiza interface de consulta SQL avan√ßada"""
    
    st.markdown("### üîç Editor SQL Avan√ßado")
    st.caption("Execute consultas SQL personalizadas")
    
    # Informa√ß√µes das tabelas dispon√≠veis
    with st.expander("üìã Tabelas Dispon√≠veis", expanded=False):
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**üìä Tabelas de Dados:**")
            system_tables = ['importacoes', 'agent_logs', 'calculation_configs']
            data_tables = [t for t in tables if t not in system_tables]
            
            for table in data_tables:
                table_info = db.get_table_info(table)
                if table_info:
                    st.caption(f"‚Ä¢ **{table}** ({table_info['total_rows']} registros)")
        
        with col2:
            st.markdown("**‚öôÔ∏è Tabelas do Sistema:**")
            for table in system_tables:
                if table in tables:
                    table_info = db.get_table_info(table)
                    if table_info:
                        st.caption(f"‚Ä¢ **{table}** ({table_info['total_rows']} registros)")
    
    # Exemplos de consultas
    with st.expander("üí° Exemplos de Consultas SQL", expanded=False):
        st.markdown("""
        **Consultas b√°sicas:**
        ```sql
        -- Listar todos os registros de uma tabela
        SELECT * FROM "nome_da_tabela" LIMIT 10;
        
        -- Contar registros
        SELECT COUNT(*) as total FROM "nome_da_tabela";
        
        -- Agrupar por coluna
        SELECT "coluna", COUNT(*) as total 
        FROM "nome_da_tabela" 
        GROUP BY "coluna";
        ```
        
        **Consultas com JOIN:**
        ```sql
        -- Juntar duas tabelas
        SELECT a.*, b.* 
        FROM "tabela_a" a 
        JOIN "tabela_b" b ON a."chave" = b."chave";
        ```
        """)
    
    # Editor SQL
    st.warning("‚ö†Ô∏è Use com cuidado! Apenas consultas SELECT s√£o recomendadas.")
    
    # Verificar se h√° SQL salvo para edi√ß√£o
    default_sql = st.session_state.get('edit_sql', '')
    if default_sql:
        st.info("üìù SQL carregado do gerador de IA")
        # Limpar ap√≥s usar
        if 'edit_sql' in st.session_state:
            del st.session_state['edit_sql']
    
    sql_query = st.text_area(
        "Digite sua consulta SQL:",
        value=default_sql,
        placeholder="SELECT * FROM \"nome_da_tabela\" LIMIT 10;",
        height=150,
        help="Digite uma consulta SQL v√°lida. Use aspas duplas para nomes de tabelas e colunas."
    )
    
    # Container para resultados do editor SQL
    sql_result_container = st.empty()
    
    # Bot√µes de a√ß√£o
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üöÄ Executar SQL", type="primary"):
            if sql_query.strip():
                execute_query_dynamic(db, sql_query, sql_result_container)
            else:
                st.warning("Digite uma consulta SQL v√°lida")
    
    with col2:
        if st.button("üßπ Limpar Editor"):
            sql_result_container.empty()  # Limpar resultados tamb√©m
            st.rerun()
    
    with col3:
        if st.button("üíæ Salvar Consulta"):
            if sql_query.strip():
                save_query_to_session("Consulta SQL Manual", sql_query)
                st.success("üíæ Consulta salva no hist√≥rico!")
            else:
                st.warning("Digite uma consulta primeiro")

def execute_query_dynamic(db, sql_query: str, container):
    """Executa consulta SQL dinamicamente sem rerun"""
    try:
        # Valida√ß√µes de seguran√ßa
        sql_upper = sql_query.upper().strip()
        
        # Permitir apenas SELECT
        if not sql_upper.startswith('SELECT'):
            with container.container():
                st.error("‚ùå Por seguran√ßa, apenas consultas SELECT s√£o permitidas!")
            return False
        
        # Bloquear comandos perigosos
        dangerous_keywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE']
        for keyword in dangerous_keywords:
            if keyword in sql_upper:
                with container.container():
                    st.error(f"‚ùå Comando '{keyword}' n√£o √© permitido por seguran√ßa!")
                return False
        
        # Executar consulta e mostrar resultado no container
        with container.container():
            # Mostrar spinner durante execu√ß√£o
            progress_placeholder = st.empty()
            with progress_placeholder:
                st.info("üîÑ Executando consulta...")
            
            # Executar consulta
            df_result = pd.read_sql(sql_query, db.engine)
            
            # Limpar spinner
            progress_placeholder.empty()
            
            if not df_result.empty:
                st.success(f"‚úÖ Consulta executada! {len(df_result)} registros encontrados.")
                
                # Mostrar dados
                if len(df_result) > 100:
                    with st.expander(f"üìä Visualizar {len(df_result)} registros", expanded=True):
                        st.dataframe(df_result, use_container_width=True, height=400)
                else:
                    st.dataframe(df_result, use_container_width=True)
                
                # Estat√≠sticas r√°pidas
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("üìä Registros", len(df_result))
                with col2:
                    st.metric("üìã Colunas", len(df_result.columns))
                with col3:
                    # Calcular tamanho aproximado em KB
                    size_kb = round(df_result.memory_usage(deep=True).sum() / 1024, 2)
                    st.metric("üíæ Tamanho", f"{size_kb} KB")
                
                # Op√ß√£o de download
                csv = df_result.to_csv(index=False)
                st.download_button(
                    label="üì• Baixar Resultado (CSV)",
                    data=csv,
                    file_name=f"consulta_ia_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                    mime="text/csv",
                    key=f"download_result_{hash(sql_query)}"
                )
                
                # Log da execu√ß√£o (sem rerun)
                log_agent_action(
                    "query_ai_agent",
                    "‚ñ∂Ô∏è Consulta IA executada com sucesso",
                    {
                        "registros_encontrados": len(df_result),
                        "colunas": list(df_result.columns)[:10]
                    }
                )
                
                return True
                
            else:
                st.warning("‚ö†Ô∏è A consulta n√£o retornou nenhum resultado.")
                st.info("üí° Dica: Verifique se os nomes das tabelas e colunas est√£o corretos.")
                
                # Log de consulta vazia (sem rerun)
                log_agent_action(
                    "query_ai_agent",
                    "‚ö†Ô∏è Consulta IA executada - sem resultados",
                    {"sql": sql_query[:100] + "..." if len(sql_query) > 100 else sql_query}
                )
                
                return False
                
    except Exception as e:
        with container.container():
            st.error(f"‚ùå Erro ao executar consulta: {str(e)}")
        
        # Log do erro (sem rerun)
        log_agent_action(
            "query_ai_agent",
            "‚ùå Erro na execu√ß√£o da consulta IA",
            {
                "erro": str(e),
                "sql": sql_query[:100] + "..." if len(sql_query) > 100 else sql_query
            }
        )
        
        return False

def execute_sql_query(db, sql_query: str):
    """Executa consulta SQL manual"""
    try:
        # Log da consulta manual
        log_agent_action(
            "manual_sql_agent",
            "üîç Consulta SQL manual executada",
            {"sql": sql_query[:200] + "..." if len(sql_query) > 200 else sql_query}
        )
        
        df_result = pd.read_sql(sql_query, db.engine)
        
        if not df_result.empty:
            st.success(f"‚úÖ Consulta executada! {len(df_result)} registros retornados.")
            
            # Mostrar dados
            if len(df_result) > 100:
                with st.expander(f"üìä Visualizar {len(df_result)} registros", expanded=True):
                    st.dataframe(df_result, use_container_width=True, height=400)
            else:
                st.dataframe(df_result, use_container_width=True)
            
            # Estat√≠sticas
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üìä Registros", len(df_result))
            with col2:
                st.metric("üìã Colunas", len(df_result.columns))
            with col3:
                size_kb = round(df_result.memory_usage(deep=True).sum() / 1024, 2)
                st.metric("üíæ Tamanho", f"{size_kb} KB")
            
            # Download
            csv = df_result.to_csv(index=False)
            st.download_button(
                label="üì• Baixar Resultado (CSV)",
                data=csv,
                file_name=f"consulta_manual_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                mime="text/csv"
            )
        else:
            st.warning("‚ö†Ô∏è A consulta n√£o retornou nenhum resultado.")
            
    except Exception as e:
        st.error(f"‚ùå Erro na consulta: {str(e)}")
        
        # Log do erro
        log_agent_action(
            "manual_sql_agent",
            "‚ùå Erro na consulta SQL manual",
            {
                "erro": str(e),
                "sql": sql_query[:100] + "..." if len(sql_query) > 100 else sql_query
            }
        )

def render_database_tools(db, tables):
    """Renderiza ferramentas de gerenciamento do banco"""
    st.subheader("üîß Ferramentas de Gerenciamento")
    
    # Informa√ß√µes do banco
    st.markdown("### üìä Informa√ß√µes do Banco")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**Arquivo do Banco:**")
        st.code("vale_refeicao.db")
        
        st.markdown("**Tipo:**")
        st.code("SQLite")
    
    with col2:
        st.markdown("**Total de Tabelas:**")
        st.code(f"{len(tables)}")
        
        # Tamanho do arquivo (se poss√≠vel)
        try:
            import os
            if os.path.exists("vale_refeicao.db"):
                size_mb = os.path.getsize("vale_refeicao.db") / (1024 * 1024)
                st.markdown("**Tamanho do Arquivo:**")
                st.code(f"{size_mb:.2f} MB")
        except:
            pass
    
    # Ferramentas de manuten√ß√£o
    st.markdown("### üõ†Ô∏è Ferramentas de Manuten√ß√£o")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üîÑ Testar Conex√£o"):
            if db.test_connection():
                st.success("‚úÖ Conex√£o OK!")
            else:
                st.error("‚ùå Falha na conex√£o")
    
    with col2:
        if st.button("üìä Atualizar Estat√≠sticas"):
            st.info("Estat√≠sticas atualizadas!")
            st.rerun()
    
    with col3:
        if st.button("üßπ Limpar Cache"):
            # Limpar cache do Streamlit
            st.cache_data.clear()
            st.success("‚úÖ Cache limpo!")
    
    # Backup e restore
    st.markdown("### üíæ Backup e Restore")
    
    st.markdown("""
    **Para fazer backup do banco de dados:**
    1. Copie o arquivo `vale_refeicao.db` para um local seguro
    2. O arquivo cont√©m todas as tabelas e dados
    
    **Para restaurar um backup:**
    1. Substitua o arquivo `vale_refeicao.db` pelo backup
    2. Reinicie a aplica√ß√£o
    """)
    
    # Prompt to Query (IA)
    st.markdown("### ü§ñ Consulta com IA (Prompt to Query)")
    if st.checkbox("Mostrar consulta com IA", key="show_ai_query"):
        render_ai_query_interface(db, tables)
    
    # SQL Query (avan√ßado)
    st.markdown("### üîç Consulta SQL Avan√ßada")
    if st.checkbox("Mostrar editor SQL", key="show_sql_editor"):
        st.warning("‚ö†Ô∏è Use com cuidado! Consultas incorretas podem afetar os dados.")
        
        sql_query = st.text_area(
            "Digite sua consulta SQL:",
            placeholder="SELECT * FROM nome_da_tabela LIMIT 10;",
            height=100
        )
        
        if st.button("‚ñ∂Ô∏è Executar Consulta"):
            if sql_query.strip():
                try:
                    df_result = pd.read_sql(sql_query, db.engine)
                    st.success(f"‚úÖ Consulta executada! {len(df_result)} registros retornados.")
                    st.dataframe(df_result, use_container_width=True)
                except Exception as e:
                    st.error(f"‚ùå Erro na consulta: {str(e)}")
            else:
                st.warning("Digite uma consulta SQL v√°lida")

def render_ai_query_interface(db, data_tables):
    """Renderiza interface de consulta com IA (Prompt to Query)"""
    
    # Verificar se OpenAI est√° configurada
    if not settings.openai_ready:
        st.error("‚ùå OpenAI API Key n√£o configurada!")
        st.markdown("""
        Para usar a consulta com IA, voc√™ precisa:
        1. Configurar sua chave OpenAI no arquivo `.env`
        2. Definir `OPENAI_API_KEY=sk-sua-chave-aqui`
        3. Reiniciar a aplica√ß√£o
        """)
        return
    
    st.info("ü§ñ Fa√ßa perguntas em linguagem natural e a IA gerar√° consultas SQL automaticamente!")
    
    # Exemplos de perguntas
    with st.expander("üí° Exemplos de Perguntas", expanded=False):
        st.markdown("""
        **Exemplos que voc√™ pode perguntar:**
        
        üìä **An√°lises gerais:**
        - "Quantos registros temos em cada tabela?"
        - "Quais s√£o as colunas da tabela funcionarios?"
        - "Mostre os primeiros 10 registros da tabela vendas"
        
        üë• **Sobre funcion√°rios:**
        - "Quantos funcion√°rios temos por departamento?"
        - "Qual √© o sal√°rio m√©dio dos funcion√°rios?"
        - "Liste os funcion√°rios admitidos em 2024"
        
        üí∞ **An√°lises financeiras:**
        - "Qual √© o total de vendas por m√™s?"
        - "Quem s√£o os 5 funcion√°rios com maior sal√°rio?"
        - "Qual departamento tem o maior custo com pessoal?"
        
        üîó **Relacionamentos:**
        - "Junte dados de funcion√°rios com seus benef√≠cios"
        - "Mostre funcion√°rios e seus departamentos"
        - "Correlacione vendas com vendedores"
        """)
    
    # Interface principal
    col1, col2 = st.columns([3, 1])
    
    with col1:
        user_question = st.text_area(
            "üí¨ Fa√ßa sua pergunta:",
            placeholder="Ex: Quantos funcion√°rios temos por departamento?",
            height=100,
            help="Descreva o que voc√™ quer saber sobre os dados em linguagem natural"
        )
    
    with col2:
        st.markdown("**üìã Tabelas dispon√≠veis:**")
        for table in data_tables:
            st.caption(f"‚Ä¢ {table}")
    
    # Bot√£o para gerar consulta
    if st.button("üöÄ Gerar Consulta SQL", type="primary"):
        if not user_question.strip():
            st.warning("‚ö†Ô∏è Digite uma pergunta primeiro!")
        else:
            with st.spinner("ü§ñ IA analisando sua pergunta e gerando SQL..."):
                try:
                    # Gerar contexto das tabelas
                    schema_context = generate_schema_context(db, data_tables)
                    
                    # Gerar SQL usando IA
                    generated_sql = generate_sql_from_prompt(user_question, schema_context)
                    
                    if generated_sql:
                        # Salvar no session_state para manter
                        st.session_state['current_generated_sql'] = generated_sql
                        st.session_state['current_question'] = user_question
                        
                        # Log da a√ß√£o
                        log_agent_action(
                            "query_ai_agent",
                            "ü§ñ Consulta SQL gerada por IA",
                            {
                                "pergunta": user_question,
                                "sql_gerado": generated_sql[:200] + "..." if len(generated_sql) > 200 else generated_sql
                            }
                        )
                    else:
                        st.error("‚ùå N√£o foi poss√≠vel gerar uma consulta SQL para esta pergunta.")
                        
                except Exception as e:
                    st.error(f"‚ùå Erro ao gerar consulta: {str(e)}")
    
    # Mostrar SQL gerado se existir (fora do bot√£o para persistir)
    if 'current_generated_sql' in st.session_state and 'current_question' in st.session_state:
        if st.session_state['current_question'] == user_question:  # S√≥ mostrar se for a mesma pergunta
            st.success("‚úÖ Consulta SQL gerada com sucesso!")
            
            # Mostrar SQL gerado
            st.markdown("**üîç SQL Gerado:**")
            st.code(st.session_state['current_generated_sql'], language='sql')
            
            # Container para resultado da execu√ß√£o
            exec_result_container = st.empty()
            
            # Op√ß√µes de a√ß√£o
            col1, col2, col3 = st.columns(3)
            
            with col1:
                if st.button("‚ñ∂Ô∏è Executar Consulta", key="exec_generated"):
                    execute_query_dynamic(db, st.session_state['current_generated_sql'], exec_result_container)
            
            with col2:
                if st.button("üìù Editar SQL", key="edit_generated"):
                    st.session_state['edit_sql'] = st.session_state['current_generated_sql']
                    st.info("SQL copiado para o editor avan√ßado abaixo!")
            
            with col3:
                if st.button("üíæ Salvar Consulta", key="save_generated"):
                    save_query_to_session(st.session_state['current_question'], st.session_state['current_generated_sql'])
                    st.success("üíæ Consulta salva no hist√≥rico!")
    
    # Se√ß√£o de limpeza de consulta (apenas se n√£o for a pergunta atual)
    if ('current_generated_sql' in st.session_state and 
        'current_question' in st.session_state and
        st.session_state['current_question'] != user_question):
        
        st.markdown("---")
        st.markdown("### üíæ Consulta Anterior")
        st.markdown(f"**Pergunta anterior:** {st.session_state['current_question']}")
        
        if st.button("üóëÔ∏è Limpar Consulta Anterior", key="clear_old_sql"):
            if 'current_generated_sql' in st.session_state:
                del st.session_state['current_generated_sql']
            if 'current_question' in st.session_state:
                del st.session_state['current_question']
            st.rerun()
    
    # Se√ß√£o removida: execu√ß√£o autom√°tica n√£o √© mais necess√°ria
    # Os resultados agora s√£o mostrados dinamicamente nos containers
    
    # Hist√≥rico de consultas
    if 'saved_queries' in st.session_state and st.session_state['saved_queries']:
        st.markdown("### üìö Hist√≥rico de Consultas")
        
        for i, query_data in enumerate(st.session_state['saved_queries']):
            with st.expander(f"üí¨ {query_data['question'][:50]}...", expanded=False):
                st.markdown(f"**Pergunta:** {query_data['question']}")
                st.code(query_data['sql'], language='sql')
                
                if st.button(f"‚ñ∂Ô∏è Executar", key=f"exec_saved_{i}"):
                    execute_generated_sql(db, query_data['sql'])

def generate_schema_context(db, data_tables):
    """Gera contexto do esquema das tabelas para a IA"""
    context = "Esquema do banco de dados SQLite:\n\n"
    
    for table in data_tables:
        table_info = db.get_table_info(table)
        if table_info:
            context += f"Tabela: {table}\n"
            context += f"Registros: {table_info['total_rows']}\n"
            context += "Colunas:\n"
            
            for col in table_info['columns']:
                pk_indicator = " (PRIMARY KEY)" if col['primary_key'] else ""
                null_indicator = " NOT NULL" if col['not_null'] else ""
                context += f"  - {col['name']}: {col['type']}{pk_indicator}{null_indicator}\n"
            
            context += "\n"
    
    return context

def generate_sql_from_prompt(question: str, schema_context: str) -> str:
    """Gera SQL usando LlamaIndex/OpenAI"""
    try:
        # Importar LlamaIndex
        from llama_index.llms.openai import OpenAI
        
        # Configurar LLM
        llm = OpenAI(
            api_key=settings.openai_api_key,
            model=settings.openai_model,
            temperature=0.1
        )
        
        # Prompt para gerar SQL
        system_prompt = f"""
Voc√™ √© um especialista em SQL que converte perguntas em linguagem natural para consultas SQL v√°lidas.

ESQUEMA DO BANCO DE DADOS:
{schema_context}

REGRAS IMPORTANTES:
1. Use apenas as tabelas e colunas fornecidas no esquema
2. Gere SQL v√°lido para SQLite
3. Use aspas duplas para nomes de tabelas e colunas: "tabela"."coluna"
4. Limite resultados com LIMIT quando apropriado
5. Use JOINs quando necess√°rio para relacionar tabelas
6. Para contagens, use COUNT(*)
7. Para m√©dias, use AVG()
8. Para agrupamentos, use GROUP BY
9. N√£o use fun√ß√µes espec√≠ficas de outros SGBDs

PERGUNTA DO USU√ÅRIO: {question}

Gere apenas a consulta SQL, sem explica√ß√µes adicionais.
"""
        
        # Gerar resposta
        response = llm.complete(system_prompt)
        
        # Extrair SQL da resposta
        sql = response.text.strip()
        
        # Limpar SQL (remover markdown se houver)
        if sql.startswith('```sql'):
            sql = sql.replace('```sql', '').replace('```', '').strip()
        elif sql.startswith('```'):
            sql = sql.replace('```', '').strip()
        
        return sql
        
    except ImportError:
        st.error("‚ùå LlamaIndex n√£o est√° instalado corretamente")
        return None
    except Exception as e:
        st.error(f"‚ùå Erro ao gerar SQL: {str(e)}")
        return None

def execute_generated_sql(db, sql: str):
    """Executa SQL gerado pela IA"""
    try:
        # Valida√ß√µes de seguran√ßa
        sql_upper = sql.upper().strip()
        
        # Permitir apenas SELECT
        if not sql_upper.startswith('SELECT'):
            st.error("‚ùå Por seguran√ßa, apenas consultas SELECT s√£o permitidas!")
            return False
        
        # Bloquear comandos perigosos
        dangerous_keywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE']
        for keyword in dangerous_keywords:
            if keyword in sql_upper:
                st.error(f"‚ùå Comando '{keyword}' n√£o √© permitido por seguran√ßa!")
                return False
        
        # Executar consulta
        df_result = pd.read_sql(sql, db.engine)
        
        if not df_result.empty:
            st.success(f"‚úÖ Consulta executada! {len(df_result)} registros encontrados.")
            
            # Mostrar dados em container expans√≠vel para grandes resultados
            if len(df_result) > 100:
                with st.expander(f"üìä Visualizar {len(df_result)} registros", expanded=True):
                    st.dataframe(df_result, use_container_width=True, height=400)
            else:
                st.dataframe(df_result, use_container_width=True)
            
            # Log da execu√ß√£o
            log_agent_action(
                "query_ai_agent",
                "‚ñ∂Ô∏è Consulta IA executada com sucesso",
                {
                    "registros_encontrados": len(df_result),
                    "colunas": list(df_result.columns)[:10]  # Primeiras 10 colunas
                }
            )
            
            # Estat√≠sticas r√°pidas
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üìä Registros", len(df_result))
            with col2:
                st.metric("üìã Colunas", len(df_result.columns))
            with col3:
                # Calcular tamanho aproximado em KB
                size_kb = round(df_result.memory_usage(deep=True).sum() / 1024, 2)
                st.metric("üíæ Tamanho", f"{size_kb} KB")
            
            # Op√ß√£o de download
            csv = df_result.to_csv(index=False)
            st.download_button(
                label="üì• Baixar Resultado (CSV)",
                data=csv,
                file_name=f"consulta_ia_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                mime="text/csv",
                key=f"download_result_{hash(sql)}"
            )
            
            return True
            
        else:
            st.warning("‚ö†Ô∏è A consulta n√£o retornou nenhum resultado.")
            st.info("üí° Dica: Verifique se os nomes das tabelas e colunas est√£o corretos.")
            
            # Log de consulta vazia
            log_agent_action(
                "query_ai_agent",
                "‚ö†Ô∏è Consulta IA executada - sem resultados",
                {"sql": sql[:100] + "..." if len(sql) > 100 else sql}
            )
            
            return False
            
    except Exception as e:
        st.error(f"‚ùå Erro ao executar consulta: {str(e)}")
        
        # Log do erro
        log_agent_action(
            "query_ai_agent",
            "‚ùå Erro na execu√ß√£o da consulta IA",
            {
                "erro": str(e),
                "sql": sql[:100] + "..." if len(sql) > 100 else sql
            }
        )
        
        return False

def save_query_to_session(question: str, sql: str):
    """Salva consulta no hist√≥rico da sess√£o"""
    if 'saved_queries' not in st.session_state:
        st.session_state['saved_queries'] = []
    
    query_data = {
        'question': question,
        'sql': sql,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    
    st.session_state['saved_queries'].append(query_data)
    
    # Manter apenas as √∫ltimas 10 consultas
    if len(st.session_state['saved_queries']) > 10:
        st.session_state['saved_queries'] = st.session_state['saved_queries'][-10:]
    
    st.success("üíæ Consulta salva no hist√≥rico!")

# Fun√ß√£o utilit√°ria que pode ser importada e usada em outros lugares
def execute_query_anywhere(db, sql_query: str, question: str = "Consulta"):
    """
    Fun√ß√£o utilit√°ria para executar consultas SQL de qualquer lugar da aplica√ß√£o
    
    Args:
        db: Inst√¢ncia do DatabaseManager
        sql_query: Consulta SQL a ser executada
        question: Descri√ß√£o da consulta (opcional)
    
    Returns:
        tuple: (success: bool, dataframe: pd.DataFrame or None, error: str or None)
    """
    try:
        # Valida√ß√µes de seguran√ßa
        sql_upper = sql_query.upper().strip()
        
        if not sql_upper.startswith('SELECT'):
            return False, None, "Apenas consultas SELECT s√£o permitidas"
        
        dangerous_keywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE']
        for keyword in dangerous_keywords:
            if keyword in sql_upper:
                return False, None, f"Comando '{keyword}' n√£o √© permitido"
        
        # Executar consulta
        df_result = pd.read_sql(sql_query, db.engine)
        
        # Log da execu√ß√£o
        log_agent_action(
            "utility_query_agent",
            f"üîç {question}",
            {
                "sql": sql_query[:200] + "..." if len(sql_query) > 200 else sql_query,
                "registros_encontrados": len(df_result) if not df_result.empty else 0
            }
        )
        
        return True, df_result, None
        
    except Exception as e:
        # Log do erro
        log_agent_action(
            "utility_query_agent",
            f"‚ùå Erro em {question}",
            {
                "erro": str(e),
                "sql": sql_query[:100] + "..." if len(sql_query) > 100 else sql_query
            }
        )
        
        return False, None, str(e)

def execute_autonomous_agent(db, data_tables, question: str, config: dict, container):
    """Executa agente aut√¥nomo de IA para an√°lise complexa"""
    
    with container.container():
        st.markdown("## üß† Agente Aut√¥nomo em A√ß√£o")
        st.markdown(f"**Pergunta:** {question}")
        
        # Inicializar progresso
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        # Container para etapas
        steps_container = st.container()
        
        try:
            # Configurar LLM
            from llama_index.llms.openai import OpenAI
            
            llm = OpenAI(
                api_key=settings.openai_api_key,
                model=settings.openai_model,
                temperature=0.3
            )
            
            # Inicializar hist√≥rico de an√°lise
            analysis_steps = []
            iteration = 0
            max_iterations = config['max_iterations']
            
            # Etapa 1: An√°lise inicial da pergunta
            status_text.text("üîç Etapa 1: Analisando pergunta e planejando abordagem...")
            progress_bar.progress(10)
            
            planning_result = plan_analysis_approach(llm, question, data_tables, db, config)
            analysis_steps.append({
                'step': 1,
                'action': 'Planejamento',
                'description': 'An√°lise da pergunta e cria√ß√£o do plano de a√ß√£o',
                'result': planning_result
            })
            
            with steps_container:
                render_analysis_step(analysis_steps[-1], config['show_reasoning'])
            
            # Etapa 2: Explora√ß√£o do esquema
            status_text.text("üìä Etapa 2: Explorando estrutura dos dados...")
            progress_bar.progress(25)
            
            schema_analysis = explore_data_schema(llm, data_tables, db, config)
            analysis_steps.append({
                'step': 2,
                'action': 'Explora√ß√£o do Esquema',
                'description': 'An√°lise detalhada da estrutura das tabelas',
                'result': schema_analysis
            })
            
            with steps_container:
                render_analysis_step(analysis_steps[-1], config['show_reasoning'])
            
            # Etapas iterativas de an√°lise
            current_context = {
                'question': question,
                'plan': planning_result,
                'schema': schema_analysis,
                'findings': []
            }
            
            while iteration < max_iterations:
                iteration += 1
                progress = 25 + (iteration / max_iterations) * 60
                progress_bar.progress(int(progress))
                
                status_text.text(f"üîÑ Etapa {iteration + 2}: Executando an√°lise iterativa ({iteration}/{max_iterations})...")
                
                # Executar itera√ß√£o de an√°lise
                iteration_result = execute_analysis_iteration(
                    llm, db, data_tables, current_context, config, iteration
                )
                
                analysis_steps.append({
                    'step': iteration + 2,
                    'action': f'An√°lise Iterativa {iteration}',
                    'description': iteration_result.get('description', 'An√°lise de dados'),
                    'result': iteration_result
                })
                
                with steps_container:
                    render_analysis_step(analysis_steps[-1], config['show_reasoning'])
                
                # Atualizar contexto
                current_context['findings'].append(iteration_result)
                
                # Verificar se an√°lise est√° completa
                if iteration_result.get('analysis_complete', False):
                    break
                
                # Log da itera√ß√£o
                log_agent_action(
                    "autonomous_agent",
                    f"üîÑ Itera√ß√£o {iteration} completada",
                    {
                        "pergunta": question[:100],
                        "iteracao": iteration,
                        "acao": iteration_result.get('action', 'An√°lise'),
                        "completa": iteration_result.get('analysis_complete', False)
                    }
                )
            
            # Etapa final: S√≠ntese e conclus√µes
            status_text.text("üéØ Finalizando: Sintetizando resultados e gerando insights...")
            progress_bar.progress(90)
            
            final_synthesis = synthesize_final_results(llm, current_context, config)
            analysis_steps.append({
                'step': len(analysis_steps) + 1,
                'action': 'S√≠ntese Final',
                'description': 'Consolida√ß√£o dos resultados e gera√ß√£o de insights',
                'result': final_synthesis
            })
            
            with steps_container:
                render_analysis_step(analysis_steps[-1], config['show_reasoning'])
            
            # Completar progresso
            progress_bar.progress(100)
            status_text.text("‚úÖ An√°lise aut√¥noma conclu√≠da!")
            
            # Salvar no hist√≥rico
            save_agent_analysis(question, analysis_steps, config, iteration)
            
            # Log final
            log_agent_action(
                "autonomous_agent",
                "‚úÖ An√°lise aut√¥noma conclu√≠da",
                {
                    "pergunta": question[:100],
                    "total_iteracoes": iteration,
                    "total_etapas": len(analysis_steps),
                    "insights_gerados": len(final_synthesis.get('insights', []))
                }
            )
            
            # Mostrar resumo final
            st.markdown("---")
            st.markdown("## üìã Resumo da An√°lise")
            
            # Usar safe_columns para evitar erro de aninhamento
            try:
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("üîÑ Itera√ß√µes", iteration)
                with col2:
                    st.metric("üìä Etapas", len(analysis_steps))
                with col3:
                    st.metric("üí° Insights", len(final_synthesis.get('insights', [])))
            except:
                # Fallback para exibi√ß√£o vertical se colunas n√£o funcionarem
                st.metric("üîÑ Itera√ß√µes", iteration)
                st.metric("üìä Etapas", len(analysis_steps))
                st.metric("üí° Insights", len(final_synthesis.get('insights', [])))
            
            return True
            
        except ImportError:
            st.error("‚ùå LlamaIndex n√£o est√° instalado corretamente")
            return False
        except Exception as e:
            st.error(f"‚ùå Erro durante an√°lise aut√¥noma: {str(e)}")
            log_agent_action(
                "autonomous_agent",
                "‚ùå Erro na an√°lise aut√¥noma",
                {
                    "erro": str(e),
                    "pergunta": question[:100],
                    "iteracao_atual": iteration
                }
            )
            return False

# Fun√ß√µes auxiliares do agente aut√¥nomo

def plan_analysis_approach(llm, question: str, data_tables: list, db, config: dict) -> dict:
    """Planeja a abordagem de an√°lise baseada na pergunta"""
    
    # Gerar contexto das tabelas
    schema_context = generate_schema_context(db, data_tables)
    
    planning_prompt = f"""
    Voc√™ √© um analista de dados experiente. Analise a pergunta do usu√°rio e crie um plano detalhado de an√°lise.

    PERGUNTA DO USU√ÅRIO: {question}

    TABELAS DISPON√çVEIS:
    {schema_context}

    PROFUNDIDADE DE EXPLORA√á√ÉO: {config['exploration_depth']}

    Crie um plano estruturado que inclua:
    1. Objetivos principais da an√°lise
    2. Tabelas que ser√£o utilizadas
    3. Tipos de an√°lises necess√°rias (estat√≠sticas, correla√ß√µes, etc.)
    4. Sequ√™ncia de etapas a serem executadas
    5. Poss√≠veis desafios e como super√°-los

    Responda em formato JSON com as chaves: objectives, tables_to_use, analysis_types, steps, challenges
    """
    
    try:
        response = llm.complete(planning_prompt)
        # Tentar parsear como JSON, se falhar, retornar estrutura b√°sica
        import json
        try:
            plan = json.loads(response.text)
        except:
            plan = {
                "objectives": ["Analisar dados conforme solicitado"],
                "tables_to_use": data_tables,
                "analysis_types": ["An√°lise explorat√≥ria"],
                "steps": ["Explorar dados", "Analisar padr√µes", "Gerar insights"],
                "challenges": ["Qualidade dos dados"]
            }
        
        return {
            "plan": plan,
            "raw_response": response.text
        }
    except Exception as e:
        return {
            "plan": {
                "objectives": ["Analisar dados conforme solicitado"],
                "tables_to_use": data_tables,
                "analysis_types": ["An√°lise explorat√≥ria"],
                "steps": ["Explorar dados", "Analisar padr√µes", "Gerar insights"],
                "challenges": ["Qualidade dos dados"]
            },
            "error": str(e)
        }

def explore_data_schema(llm, data_tables: list, db, config: dict) -> dict:
    """Explora o esquema dos dados em detalhes"""
    
    schema_details = {}
    sample_data = {}
    
    for table in data_tables:
        # Obter informa√ß√µes da tabela
        table_info = db.get_table_info(table)
        if table_info:
            schema_details[table] = table_info
            
            # Obter amostra de dados se configurado para explora√ß√£o avan√ßada
            if config['exploration_depth'] in ['Intermedi√°ria', 'Avan√ßada']:
                try:
                    sample_query = f'SELECT * FROM "{table}" LIMIT 5'
                    df_sample = pd.read_sql(sample_query, db.engine)
                    sample_data[table] = df_sample.to_dict('records')
                except:
                    sample_data[table] = []
    
    # An√°lise com IA se configurado
    if config['exploration_depth'] == 'Avan√ßada':
        analysis_prompt = f"""
        Analise o esquema das tabelas e identifique:
        1. Relacionamentos potenciais entre tabelas
        2. Qualidade dos dados (campos vazios, inconsist√™ncias)
        3. Oportunidades de an√°lise
        4. Poss√≠veis problemas nos dados

        ESQUEMA DAS TABELAS:
        {schema_details}

        AMOSTRAS DE DADOS:
        {sample_data}

        Forne√ßa insights sobre a estrutura dos dados.
        """
        
        try:
            response = llm.complete(analysis_prompt)
            ai_insights = response.text
        except:
            ai_insights = "An√°lise autom√°tica n√£o dispon√≠vel"
    else:
        ai_insights = "An√°lise b√°sica do esquema"
    
    return {
        "schema_details": schema_details,
        "sample_data": sample_data,
        "ai_insights": ai_insights,
        "total_tables": len(data_tables),
        "total_columns": sum(len(info.get('columns', [])) for info in schema_details.values())
    }

def execute_analysis_iteration(llm, db, data_tables: list, context: dict, config: dict, iteration: int) -> dict:
    """Executa uma itera√ß√£o de an√°lise"""
    
    # Determinar pr√≥xima a√ß√£o baseada no contexto
    action_prompt = f"""
    Voc√™ est√° na itera√ß√£o {iteration} de uma an√°lise de dados.

    CONTEXTO ATUAL:
    - Pergunta: {context['question']}
    - Plano: {context['plan']}
    - Esquema: {context['schema']}
    - Descobertas anteriores: {context['findings'][-2:] if context['findings'] else 'Nenhuma'}

    Determine a pr√≥xima a√ß√£o mais √∫til:
    1. Consulta SQL espec√≠fica para explorar dados
    2. An√°lise estat√≠stica de uma tabela
    3. Correla√ß√£o entre tabelas
    4. Verifica√ß√£o de qualidade dos dados
    5. Finalizar an√°lise (se j√° tem informa√ß√µes suficientes)

    Responda com:
    - action_type: tipo da a√ß√£o (1-5)
    - sql_query: consulta SQL se aplic√°vel
    - description: descri√ß√£o da a√ß√£o
    - analysis_complete: true se an√°lise deve ser finalizada
    """
    
    try:
        response = llm.complete(action_prompt)
        
        # Parsear resposta (implementa√ß√£o simplificada)
        response_text = response.text.lower()
        
        if "finalizar" in response_text or "analysis_complete: true" in response_text:
            return {
                "action_type": "finalize",
                "description": "An√°lise considerada completa",
                "analysis_complete": True,
                "findings": "Dados suficientes coletados para conclus√£o"
            }
        
        # Executar consulta explorat√≥ria simples
        table = data_tables[iteration % len(data_tables)]  # Rotacionar entre tabelas
        
        queries = [
            f'SELECT COUNT(*) as total_records FROM "{table}"',
            f'SELECT * FROM "{table}" LIMIT 10',
            f'SELECT COUNT(DISTINCT *) as unique_records FROM "{table}"'
        ]
        
        query = queries[iteration % len(queries)]
        
        try:
            df_result = pd.read_sql(query, db.engine)
            query_result = df_result.to_dict('records')
        except Exception as e:
            query_result = f"Erro na consulta: {str(e)}"
        
        return {
            "action_type": "sql_query",
            "sql_query": query,
            "description": f"An√°lise explorat√≥ria da tabela {table}",
            "query_result": query_result,
            "analysis_complete": iteration >= 3,  # Completar ap√≥s 3 itera√ß√µes por padr√£o
            "findings": f"Dados coletados da tabela {table}"
        }
        
    except Exception as e:
        return {
            "action_type": "error",
            "description": f"Erro na itera√ß√£o {iteration}",
            "error": str(e),
            "analysis_complete": True
        }

def synthesize_final_results(llm, context: dict, config: dict) -> dict:
    """Sintetiza os resultados finais da an√°lise"""
    
    synthesis_prompt = f"""
    Sintetize os resultados da an√°lise completa:

    PERGUNTA ORIGINAL: {context['question']}
    PLANO EXECUTADO: {context['plan']}
    DESCOBERTAS: {context['findings']}

    Forne√ßa:
    1. Resposta direta √† pergunta
    2. Principais insights descobertos
    3. Recomenda√ß√µes baseadas nos dados
    4. Limita√ß√µes da an√°lise
    5. Pr√≥ximos passos sugeridos

    Seja claro, objetivo e baseie-se apenas nos dados analisados.
    """
    
    try:
        response = llm.complete(synthesis_prompt)
        
        # Gerar insights estruturados
        insights = [
            "An√°lise dos dados conclu√≠da",
            "Padr√µes identificados nos dados",
            "Recomenda√ß√µes baseadas em evid√™ncias"
        ]
        
        if config['include_insights']:
            insights.extend([
                "Oportunidades de melhoria identificadas",
                "√Åreas que requerem aten√ß√£o especial"
            ])
        
        return {
            "final_answer": response.text,
            "insights": insights,
            "recommendations": [
                "Continuar monitoramento dos dados",
                "Implementar melhorias sugeridas",
                "Realizar an√°lises peri√≥dicas"
            ],
            "limitations": [
                "An√°lise baseada em dados dispon√≠veis",
                "Resultados dependem da qualidade dos dados"
            ]
        }
        
    except Exception as e:
        return {
            "final_answer": "An√°lise conclu√≠da com base nos dados dispon√≠veis",
            "insights": ["Dados analisados com sucesso"],
            "error": str(e)
        }

def render_analysis_step(step: dict, show_reasoning: bool):
    """Renderiza uma etapa da an√°lise"""
    
    with st.expander(f"üîç Etapa {step['step']}: {step['action']}", expanded=True):
        st.markdown(f"**Descri√ß√£o:** {step['description']}")
        
        result = step['result']
        
        if show_reasoning and isinstance(result, dict):
            if 'plan' in result:
                st.markdown("**üìã Plano de A√ß√£o:**")
                plan = result['plan']
                if isinstance(plan, dict):
                    for key, value in plan.items():
                        if isinstance(value, list):
                            st.markdown(f"- **{key.replace('_', ' ').title()}:** {', '.join(map(str, value))}")
                        else:
                            st.markdown(f"- **{key.replace('_', ' ').title()}:** {value}")
            
            if 'sql_query' in result:
                st.markdown("**üîç Consulta Executada:**")
                st.code(result['sql_query'], language='sql')
                
            if 'query_result' in result:
                st.markdown("**üìä Resultado:**")
                if isinstance(result['query_result'], list):
                    st.json(result['query_result'])
                else:
                    st.write(result['query_result'])
            
            if 'ai_insights' in result:
                st.markdown("**üß† Insights da IA:**")
                st.write(result['ai_insights'])
            
            if 'final_answer' in result:
                st.markdown("**üéØ Resposta Final:**")
                st.write(result['final_answer'])
                
                if 'insights' in result:
                    st.markdown("**üí° Principais Insights:**")
                    for insight in result['insights']:
                        st.markdown(f"- {insight}")

def save_agent_analysis(question: str, steps: list, config: dict, iterations: int):
    """Salva an√°lise do agente no hist√≥rico"""
    
    if 'agent_analyses' not in st.session_state:
        st.session_state['agent_analyses'] = []
    
    analysis = {
        'question': question,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'steps': steps,
        'config': config,
        'iterations': iterations,
        'total_steps': len(steps)
    }
    
    st.session_state['agent_analyses'].append(analysis)
    
    # Manter apenas as √∫ltimas 10 an√°lises
    if len(st.session_state['agent_analyses']) > 10:
        st.session_state['agent_analyses'] = st.session_state['agent_analyses'][-10:]
